<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>j/q/x+uå‘éŸ³è§„åˆ™æµ‹è¯•</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .test-char {
            display: inline-block;
            margin: 10px;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 8px;
            cursor: pointer;
            font-size: 24px;
            font-weight: bold;
            transition: all 0.3s;
        }
        .test-char:hover {
            background: #bbdefb;
            transform: scale(1.05);
        }
        .pinyin {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>j/q/x+uå‘éŸ³è§„åˆ™æµ‹è¯•</h1>
    
    <div class="test-container">
        <h2>æµ‹è¯•æ±‰å­—ï¼ˆç‚¹å‡»æµ‹è¯•æ‹¼éŸ³åˆ†è§£ï¼‰</h2>
        <div class="test-char" onclick="testPronunciation('å»', 'qÃ¹')">
            å»<div class="pinyin">qÃ¹</div>
        </div>
        <div class="test-char" onclick="testPronunciation('å–', 'qÇ”')">
            å–<div class="pinyin">qÇ”</div>
        </div>
        <div class="test-char" onclick="testPronunciation('æ›²', 'qÅ«')">
            æ›²<div class="pinyin">qÅ«</div>
        </div>
        <div class="test-char" onclick="testPronunciation('è¶£', 'qÃ¹')">
            è¶£<div class="pinyin">qÃ¹</div>
        </div>
        <div class="test-char" onclick="testPronunciation('ä¸¾', 'jÇ”')">
            ä¸¾<div class="pinyin">jÇ”</div>
        </div>
        <div class="test-char" onclick="testPronunciation('å¥', 'jÃ¹')">
            å¥<div class="pinyin">jÃ¹</div>
        </div>
        <div class="test-char" onclick="testPronunciation('è®¸', 'xÇ”')">
            è®¸<div class="pinyin">xÇ”</div>
        </div>
        <div class="test-char" onclick="testPronunciation('ç»­', 'xÃ¹')">
            ç»­<div class="pinyin">xÃ¹</div>
        </div>
    </div>
    
    <div class="test-container">
        <h2>æµ‹è¯•æ—¥å¿—</h2>
        <div id="testLog" class="log"></div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let pinyinToCharacterMap = {};
        
        function log(message) {
            const logDiv = document.getElementById('testLog');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${message}<br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // æ‹¼éŸ³åˆ†è§£å‡½æ•°ï¼ˆç®€åŒ–ç‰ˆï¼Œä¸“é—¨ç”¨äºæµ‹è¯•j/q/x+uè§„åˆ™ï¼‰
        function decomposePinyin(pinyin, character = '') {
            console.log('=== æ‹¼éŸ³åˆ†è§£å‡½æ•°æµ‹è¯•ç‰ˆ ===');
            console.log('è¾“å…¥æ‹¼éŸ³:', pinyin, 'æ±‰å­—:', character);
            
            let result = [];
            let originalPinyin = pinyin.toLowerCase();
            
            // åˆ†è§£å£°æ¯å’ŒéŸµæ¯
            let shengmu = '';
            let yunmu = '';
            
            // è¯†åˆ«å£°æ¯
            const shengmuList = ['zh', 'ch', 'sh', 'b', 'p', 'm', 'f', 'd', 't', 'n', 'l', 'g', 'k', 'h', 'j', 'q', 'x', 'r', 'z', 'c', 's', 'y', 'w'];
            
            for (let sm of shengmuList) {
                if (originalPinyin.startsWith(sm)) {
                    shengmu = sm;
                    yunmu = originalPinyin.substring(sm.length);
                    break;
                }
            }
            
            if (!shengmu) {
                yunmu = originalPinyin;
            }
            
            console.log('å£°æ¯:', shengmu, 'éŸµæ¯:', yunmu);
            
            // æ·»åŠ å£°æ¯æ˜ å°„
            if (shengmu) {
                const shengmuMapping = pinyinToCharacterMap['å£°æ¯æ˜ å°„'] && pinyinToCharacterMap['å£°æ¯æ˜ å°„'][shengmu];
                if (shengmuMapping) {
                    result.push(shengmuMapping);
                    console.log('æ·»åŠ å£°æ¯æ˜ å°„:', shengmu, 'â†’', shengmuMapping);
                } else {
                    result.push(shengmu);
                }
            }

            // å¤„ç†j/q/x+uçš„ç‰¹æ®Šè§„åˆ™
            if (['j', 'q', 'x'].includes(shengmu) && yunmu.startsWith('u')) {
                console.log('æ£€æµ‹åˆ°j/q/x+uç»„åˆï¼Œå°†uè½¬æ¢ä¸ºÃ¼éŸ³');
                const uToUMap = {
                    'u': 'Ã¼',
                    'Å«': 'Ç–', 
                    'Ãº': 'Ç˜',
                    'Ç”': 'Çš',
                    'Ã¹': 'Çœ'
                };
                
                for (let [uTone, umlautTone] of Object.entries(uToUMap)) {
                    if (yunmu.startsWith(uTone)) {
                        yunmu = yunmu.replace(uTone, umlautTone);
                        console.log('éŸµæ¯è½¬æ¢:', yunmu);
                        break;
                    }
                }
            }
            
            // å¤„ç†éŸµæ¯
            if (yunmu) {
                const yunmuMapping = pinyinToCharacterMap['éŸµæ¯æ˜ å°„'] && pinyinToCharacterMap['éŸµæ¯æ˜ å°„'][yunmu];
                if (yunmuMapping) {
                    result.push(yunmuMapping);
                    console.log('æ·»åŠ éŸµæ¯æ˜ å°„:', yunmu, 'â†’', yunmuMapping);
                } else {
                    result.push(yunmu);
                }
            }
            
            console.log('æœ€ç»ˆåˆ†è§£ç»“æœ:', result);
            return result;
        }

        function testPronunciation(character, pinyin) {
            log(`\n=== æµ‹è¯•æ±‰å­—: ${character} (${pinyin}) ===`);
            
            const decomposition = decomposePinyin(pinyin, character);
            log(`æ‹¼éŸ³åˆ†è§£ç»“æœ: ${JSON.stringify(decomposition)}`);
            
            // æµ‹è¯•é¢„æœŸç»“æœ
            if (character === 'å»') {
                const expected = ['ä¸ƒ', 'è‚²'];
                const isCorrect = JSON.stringify(decomposition) === JSON.stringify(expected);
                log(`é¢„æœŸç»“æœ: ${JSON.stringify(expected)}`);
                log(`æµ‹è¯•ç»“æœ: ${isCorrect ? 'âœ… é€šè¿‡' : 'âŒ å¤±è´¥'}`);
            }
            
            // ç®€å•çš„è¯­éŸ³æµ‹è¯•
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(decomposition.join(' '));
                utterance.lang = 'zh-CN';
                speechSynthesis.speak(utterance);
                log(`ğŸ”Š æ’­æ”¾åˆ†è§£å‘éŸ³: ${decomposition.join(' ')}`);
            }
        }

        // åŠ è½½æ‹¼éŸ³æ˜ å°„æ•°æ®
        async function loadPinyinMapping() {
            try {
                const response = await fetch('pinyinToCharacterMap.json');
                pinyinToCharacterMap = await response.json();
                log('âœ… æ‹¼éŸ³æ˜ å°„æ•°æ®åŠ è½½æˆåŠŸ');
                return pinyinToCharacterMap;
            } catch (error) {
                log(`âŒ æ‹¼éŸ³æ˜ å°„æ•°æ®åŠ è½½å¤±è´¥: ${error.message}`);
                throw error;
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        window.onload = async function() {
            log('é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹æµ‹è¯•j/q/x+uå‘éŸ³è§„åˆ™');
            
            try {
                await loadPinyinMapping();
                log('âœ… åˆå§‹åŒ–å®Œæˆï¼Œå¯ä»¥å¼€å§‹æµ‹è¯•');
                
                // è‡ªåŠ¨æµ‹è¯•"å»"å­—
                setTimeout(() => {
                    testPronunciation('å»', 'qÃ¹');
                }, 500);
            } catch (error) {
                log(`âŒ åˆå§‹åŒ–å¤±è´¥: ${error.message}`);
            }
        };
    </script>
</body>
</html>